sigma_e2_hat = sigma_e2_hat + t(S[,i]) %*% S[,i] - t(S[,i])
%*% Zmat %*% solve(t(Zmat)%*%Zmat) %*% t(Zmat)%*%S[,i]
}
sigma_e2_hat = sigma_e2_hat/(n*(m-q))
#### hat(Sigma_Theta)
Sigma_Theta = matrix(rep(0, q^2), nrow = q)
for(i in 1:n) {
X = solve(t(Zmat) %*% Zmat) %*% t(Zmat) %*% (S[,i]-Ybar)
%*% t(S[,i]-Ybar) %*% Zmat %*% solve(t(Zmat) %*% Zmat)
Sigma_Theta = Sigma_Theta + X
}
Sigma_Theta = Sigma_Theta/n - as.numeric(sigma_e2_hat) * solve(t(Zmat) %*% Zmat)
#### hat(s(t))
st = c()
for(i in 1:m) {
x = sqrt(t(Zmat[i, ]) %*% Sigma_Theta %*% Zmat[i, ])
st = c(st, x)
}
##### hat(R(t))
Rt = c()
for(i in 1:m) {
x = (t(Zmat[i, ]) %*% theta_hat - eta) / st[i]
Rt = c(Rt, pnorm(x))
}
mylist = list("theta_hat" = theta_hat, "sigma_e2_hat" = sigma_e2_hat,
"Sigma_Theta_hat" = Sigma_Theta, "Rt" = Rt)
return(mylist)
}
clear()
q = 4
n = 100 ## number of sample components
T = seq(1, 4, length = 10)
m = length(T)  ##number of time points
Z = function(t) {
return(matrix(c(12-0.5*t^2, -2*t, log(3+1/t), exp(-t)), ncol = 1))
}
sigma_e = 0.05
### declare cutoff
eta = 20
### define paramters for Theta_i
library(MASS)
theta = c(4, 3, 5, 5)
Sigma = matrix(c(0.75, -.27, .092, -.21, -.27, .86,
.15, .049, .092, .15, .75, -.071,
-.21, .049, -0.071, .24), nrow = q)
Simu = function(n, m, q, theta, Sigma, sigma_e) {
Datmat = matrix(nrow = m, ncol = n)
for(i in 1:n) {
Theta = mvrnorm(1, theta, Sigma)
for(j in 1:m){
Datmat[j, i] = t(Z(T[j])) %*% Theta + rnorm(1, mean = 0, sd = sigma_e)
}
}
mylist = list("data" = Datmat)
return(mylist)
}
Estim = function(n, m, q, S, Z, T) {
Zmat = matrix(nrow = m, ncol = q)
for(i in 1:m){
Zmat[i, ] = Z(T[i])
}
Ybar = 0
for(i in 1:n){
Ybar = Ybar + S[, i]
}
Ybar = Ybar/n
#### hat(theta)_n
theta_hat = solve(t(Zmat) %*% Zmat) %*% t(Zmat) %*% Ybar
#### hat(sigma)_e^2
sigma_e2_hat = 0
for(i in 1:n) {
sigma_e2_hat = sigma_e2_hat + t(S[,i]) %*% S[,i] - t(S[,i])
%*% Zmat %*% solve(t(Zmat)%*%Zmat) %*% t(Zmat)%*%S[,i]
}
sigma_e2_hat = sigma_e2_hat/(n*(m-q))
#### hat(Sigma_Theta)
Sigma_Theta = matrix(rep(0, q^2), nrow = q)
for(i in 1:n) {
X = solve(t(Zmat) %*% Zmat) %*% t(Zmat) %*% (S[,i]-Ybar)
%*% t(S[,i]-Ybar) %*% Zmat %*% solve(t(Zmat) %*% Zmat)
Sigma_Theta = Sigma_Theta + X
}
Sigma_Theta = Sigma_Theta/n - as.numeric(sigma_e2_hat) * solve(t(Zmat) %*% Zmat)
#### hat(s(t))
st = c()
for(i in 1:m) {
x = sqrt(t(Zmat[i, ]) %*% Sigma_Theta %*% Zmat[i, ])
st = c(st, x)
}
##### hat(R(t))
Rt = c()
for(i in 1:m) {
x = (t(Zmat[i, ]) %*% theta_hat - eta) / st[i]
Rt = c(Rt, pnorm(x))
}
mylist = list("theta_hat" = theta_hat, "sigma_e2_hat" = sigma_e2_hat,
"Sigma_Theta_hat" = Sigma_Theta, "Rt" = Rt)
return(mylist)
}
sigma_e = 0.05
### declare cutoff
eta = 20
### define paramters for Theta_i
library(MASS)
theta = c(4, 3, 5, 5)
Sigma = matrix(c(0.75, -.27, .092, -.21, -.27, .86,
.15, .049, .092, .15, .75, -.071,
-.21, .049, -0.071, .24), nrow = q)
Simu = function(n, m, q, theta, Sigma, sigma_e) {
Datmat = matrix(nrow = m, ncol = n)
for(i in 1:n) {
Theta = mvrnorm(1, theta, Sigma)
for(j in 1:m){
Datmat[j, i] = t(Z(T[j])) %*% Theta + rnorm(1, mean = 0, sd = sigma_e)
}
}
mylist = list("data" = Datmat)
return(mylist)
}
Estim = function(n, m, q, S, Z, T) {
Zmat = matrix(nrow = m, ncol = q)
for(i in 1:m){
Zmat[i, ] = Z(T[i])
}
Ybar = 0
for(i in 1:n){
Ybar = Ybar + S[, i]
}
Ybar = Ybar/n
#### hat(theta)_n
theta_hat = solve(t(Zmat) %*% Zmat) %*% t(Zmat) %*% Ybar
#### hat(sigma)_e^2
sigma_e2_hat = 0
for(i in 1:n) {
sigma_e2_hat = sigma_e2_hat + t(S[,i]) %*% S[,i] - t(S[,i]) %*% Zmat %*% solve(t(Zmat)%*%Zmat) %*% t(Zmat)%*%S[,i]
}
sigma_e2_hat = sigma_e2_hat/(n*(m-q))
#### hat(Sigma_Theta)
Sigma_Theta = matrix(rep(0, q^2), nrow = q)
for(i in 1:n) {
X = solve(t(Zmat) %*% Zmat) %*% t(Zmat) %*% (S[,i]-Ybar) %*% t(S[,i]-Ybar) %*% Zmat %*% solve(t(Zmat) %*% Zmat)
Sigma_Theta = Sigma_Theta + X
}
Sigma_Theta = Sigma_Theta/n - as.numeric(sigma_e2_hat) * solve(t(Zmat) %*% Zmat)
#### hat(s(t))
st = c()
for(i in 1:m) {
x = sqrt(t(Zmat[i, ]) %*% Sigma_Theta %*% Zmat[i, ])
st = c(st, x)
}
##### hat(R(t))
Rt = c()
for(i in 1:m) {
x = (t(Zmat[i, ]) %*% theta_hat - eta) / st[i]
Rt = c(Rt, pnorm(x))
}
mylist = list("theta_hat" = theta_hat, "sigma_e2_hat" = sigma_e2_hat,
"Sigma_Theta_hat" = Sigma_Theta, "Rt" = Rt)
return(mylist)
}
vjack = function(n, m, S) {
Jmat = matrix(nrow = n, ncol = m)
for(i in 1:n) {
S_new = S[, -i]
result = Estim((n-1), m, q, S_new, Z, T)
Jmat[i, ] = result$Rt
}
return(((n-1)^2/n) * diag(var(Jmat)))
}
vboot = function(B = 200, m, S) {
Bmat = matrix(nrow = B, ncol = m)
for(b in 1:B) {
S_new = S[ , sample(n, n, replace = TRUE)]
result = Estim(n, m, q, S_new, Z, T)
Bmat[b, ] = result$Rt
}
return(((B-1)/B) * diag(var(Bmat)))
}
### repeating Jackknife and Bootstrap multiple times
N = 100; v_jack = c(); v_boot = c()
for(i in 1:N) {
set.seed(i)
S = Simu(n,m,q,theta, Sigma, sigma_e)$data
v_jack = rbind(v_jack, vjack(n, m, S))
v_boot = rbind(v_boot, vboot(B, m, S))
}
gradg = function(x1, x2, x3, i) {
d = x2 - x1^2 - x3*(t(Zmat[i, ])%*%(solve(t(Zmat)%*%Zmat))%*%Zmat[i,])
g1 = dnorm((x1 - eta)/sqrt(d)) * (sqrt(d) + (x1 - eta)*x1/sqrt(d))/d
g2 = dnorm((x1 - eta)/sqrt(d)) * (-0.5*(x1 - eta)/sqrt(d))/d
g3 = dnorm((x1 - eta)/sqrt(d)) *
(0.5*(x1 - eta)*(t(Zmat[i, ])%*%(solve(t(Zmat)%*%Zmat))%*%Zmat[i,])/sqrt(d))/d
return(c(g1, g2, g3))
}
N = 100; v_L = c()
for(i in 1:N) {
set.seed(i)
S = Simu(n,m,q,theta, Sigma, sigma_e)$data
M=solve(t(Zmat)%*%Zmat)
K=Zmat%*%M%*%t(Zmat)
v_linear = c()
for(t in 1:m) {
P=t(Zmat[t, ])%*%M%*%t(Zmat)
f1<-function(v)
{
return(P%*%v)
}
x1=apply(S, 2, f1)
x2=x1^2
f2<-function(v)
{
return(t(v)%*%v-t(v)%*%K%*%v)
}
x3=apply(S, 2, f2)/(m-q)
X=cbind(x1, x2, x3)
Sigma_hat_X=var(X)
u=colMeans(X)
g=grad(u[1],u[2],u[3], t)
v=(t(g)%*%Sigma_hat_X%*%g)/n
v_linear = c(v_linear, v)
}
v_L = rbind(v_L, v_linear)
}
v_jack
dim(v_jack)
### repeating Jackknife and Bootstrap multiple times
N = 100; v_jack = c(); v_boot = c()
for(i in 1:N) {
set.seed(i)
S = Simu(n,m,q,theta, Sigma, sigma_e)$data
v_jack = rbind(v_jack, vjack(n, m, S))
v_boot = rbind(v_boot, vboot(B, m, S))
}
dim(v_jack)
gradg = function(x1, x2, x3, i) {
d = x2 - x1^2 - x3*(t(Zmat[i, ])%*%(solve(t(Zmat)%*%Zmat))%*%Zmat[i,])
g1 = dnorm((x1 - eta)/sqrt(d)) * (sqrt(d) + (x1 - eta)*x1/sqrt(d))/d
g2 = dnorm((x1 - eta)/sqrt(d)) * (-0.5*(x1 - eta)/sqrt(d))/d
g3 = dnorm((x1 - eta)/sqrt(d)) *
(0.5*(x1 - eta)*(t(Zmat[i, ])%*%(solve(t(Zmat)%*%Zmat))%*%Zmat[i,])/sqrt(d))/d
return(c(g1, g2, g3))
}
N = 100; v_L = c()
for(i in 1:N) {
set.seed(i)
S = Simu(n,m,q,theta, Sigma, sigma_e)$data
M=solve(t(Zmat)%*%Zmat)
K=Zmat%*%M%*%t(Zmat)
v_linear = c()
for(t in 1:m) {
P=t(Zmat[t, ])%*%M%*%t(Zmat)
f1<-function(v)
{
return(P%*%v)
}
x1=apply(S, 2, f1)
x2=x1^2
f2<-function(v)
{
return(t(v)%*%v-t(v)%*%K%*%v)
}
x3=apply(S, 2, f2)/(m-q)
X=cbind(x1, x2, x3)
Sigma_hat_X=var(X)
u=colMeans(X)
g=grad(u[1],u[2],u[3], t)
v=(t(g)%*%Sigma_hat_X%*%g)/n
v_linear = c(v_linear, v)
}
v_L = rbind(v_L, v_linear)
}
N = 100; v_L = c()
Zmat = matrix(nrow = m, ncol = q)
for(i in 1:m){
Zmat[i, ] = Z(T[i])
}
for(i in 1:N) {
set.seed(i)
S = Simu(n,m,q,theta, Sigma, sigma_e)$data
M=solve(t(Zmat)%*%Zmat)
K=Zmat%*%M%*%t(Zmat)
v_linear = c()
for(t in 1:m) {
P=t(Zmat[t, ])%*%M%*%t(Zmat)
f1<-function(v)
{
return(P%*%v)
}
x1=apply(S, 2, f1)
x2=x1^2
f2<-function(v)
{
return(t(v)%*%v-t(v)%*%K%*%v)
}
x3=apply(S, 2, f2)/(m-q)
X=cbind(x1, x2, x3)
Sigma_hat_X=var(X)
u=colMeans(X)
g=grad(u[1],u[2],u[3], t)
v=(t(g)%*%Sigma_hat_X%*%g)/n
v_linear = c(v_linear, v)
}
v_L = rbind(v_L, v_linear)
}
for(i in 1:N) {
set.seed(i)
S = Simu(n,m,q,theta, Sigma, sigma_e)$data
M=solve(t(Zmat)%*%Zmat)
K=Zmat%*%M%*%t(Zmat)
v_linear = c()
for(t in 1:m) {
P=t(Zmat[t, ])%*%M%*%t(Zmat)
f1<-function(v)
{
return(P%*%v)
}
x1=apply(S, 2, f1)
x2=x1^2
f2<-function(v)
{
return(t(v)%*%v-t(v)%*%K%*%v)
}
x3=apply(S, 2, f2)/(m-q)
X=cbind(x1, x2, x3)
Sigma_hat_X=var(X)
u=colMeans(X)
g=gradg(u[1],u[2],u[3], t)
v=(t(g)%*%Sigma_hat_X%*%g)/n
v_linear = c(v_linear, v)
}
v_L = rbind(v_L, v_linear)
}
summary(v_jack)
summary(v_boot)
summary(v_L)
dim(v_jack)
report_mean_matrix = matrix(nrow = m, ncol = 3)
report_sd_matrix = matrix(nrow = m, ncol = 3)
for(j in 1:m) {
report_mean_matrix[j, 1] = mean(v_jack[, j])
report_mean_matrix[j, 2] = mean(v_boot[, j])
report_mean_matrix[j, 3] = mean(v_L[, j])
report_sd_matrix[j, 1] = sd(v_jack[, j])
report_sd_matrix[j, 2] = sd(v_boot[, j])
report_sd_matrix[j, 3] = mean(v_L[, j])
}
report_mean_matrix
report_sd_matrix
v=c(1,4,9)
mean(sqrt(v))
report_mean_matrix = matrix(nrow = m, ncol = 3)
report_sd_matrix = matrix(nrow = m, ncol = 3)
for(j in 1:m) {
report_mean_matrix[j, 1] = mean(sqrt(v_jack[, j]))
report_mean_matrix[j, 2] = mean(sqrt(v_boot[, j]))
report_mean_matrix[j, 3] = mean(sqrt(v_L[, j]))
report_sd_matrix[j, 1] = sd(sqrt(v_jack[, j]))
report_sd_matrix[j, 2] = sd(sqrt(v_boot[, j]))
report_sd_matrix[j, 3] = mean(sqrt(v_L[, j]))
}
report_mean_matrix
report_sd_matrix
library(tidyverse)
install.packages("tidyverse")
install.packages(c("ggthemes", "gganimate"))
library(tidyverse)
library(tidyverse)
library(tidyverse)
warnings()
library(tidyverse)
install.packages("tidyverse")
install.packages("tidyverse")
library(tidyverse)
library(ggthemes)
library(gganimate)
library(tidyverse)
library(ggthemes)
library(gganimate)
run.sims = function(a.cvr, b.cvr,
max.obs = 100000, obs.increments = 2000,
n.simulations = 500, seed.value = 5){
# When to 'check' experiment results
checkins = seq(from = obs.increments, to = max.obs, by = obs.increments)
checkins = rep(checkins, times = n.simulations)
# Run 'experiments'
for(i in 1:n.simulations){
# Get the experiment results
a.obs = rbernoulli(n = max.obs, p = a.cvr)
b.obs = rbernoulli(n = max.obs, p = b.cvr)
all.obs = data.frame(n.sim = i, time = 1:max.obs, a.obs, b.obs)
# Record the observed result at each experiment 'check-in'
all.obs = all.obs %>%
mutate(checkin = ceiling(time / obs.increments) * obs.increments) %>%
group_by(n.sim, checkin) %>%
summarise(a.conv = sum(a.obs),
b.conv = sum(b.obs)) %>%
group_by(n.sim) %>%
mutate(a.conv = cumsum(a.conv),
b.conv = cumsum(b.conv))
# Add these results to the record of all experiments
if(i == 1){
experiment.record = all.obs
} else {
experiment.record = rbind(experiment.record, all.obs)
}
#experiment.record = rbind(experiment.record, all.obs)
}
return(experiment.record)
}
getloss = function(sims, seed.value = 20,
post.samples = 5000,
prior.alpha = 1, prior.beta = 1){
# Create variables to store the loss estimates
sims = sims %>% mutate(loss.a = NA, loss.b = NA)
# At every check-in time, estimate the loss
for(i in 1:nrow(sims)){
a.sample = rbeta(n = post.samples,
shape1 = prior.alpha + sims$a.conv[i],
shape2 = prior.beta + sims$checkin[i] - sims$a.conv[i])
b.sample = rbeta(n = post.samples,
shape1 = prior.alpha + sims$b.conv[i],
shape2 = prior.beta + sims$checkin[i] - sims$b.conv[i])
sims$loss.a[i] = mean((a.sample < b.sample) * (b.sample - a.sample))
sims$loss.b[i] = mean((a.sample > b.sample) * (a.sample - b.sample))
}
# Returns the original dataframe enriched with expected loss
return(sims)
}
uni.obs = data.frame(obs = rbeta(n = 10000000, shape1 = 1, shape2 = 1))
ggplot(data = uni.obs, aes(x = obs)) +
geom_density(colour = "blue", fill = "blue", alpha = 0.2) +
ggtitle("Beta(1,1) prior distribution") +
labs(x = "Conversion rate", y = "Density") +
theme_tufte()
sim1 = run.sims(a.cvr = 0.0020, b.cvr = 0.0025, n.simulations = 500)
sim1 = getloss(sim1)
one.exp =
sim1 %>%
filter(n.sim == 5) %>%
mutate(variant = "A",
loss = loss.a,
cvr = a.conv / checkin)
one.exp.b = one.exp %>%
mutate(variant = "B",
loss = loss.b,
cvr = b.conv / checkin)
one.exp = rbind(one.exp, one.exp.b)
exp.plot.cvr = one.exp %>%
ggplot(aes(x = checkin, y = cvr, colour = factor(variant))) +
geom_line() +
theme_tufte() +
ggtitle("Observed conversion rates in one experiment") +
labs(x = "Observations for each variant", y = "Conversion rate", colour = "variant") +
transition_reveal(checkin)
exp.plot.cvr
anim_save(filename = "single_experiment_cvr.gif", animation = last_animation())
?anim_save
exp.plot = sim1 %>%
filter(n.sim>= 1, n.sim <= 100) %>%
ggplot(aes(x = checkin, colour = factor(n.sim), y = loss.b)) +
#geom_line(aes(y = loss.a, colour = "Variant A (true rate 0.20%)")) +
geom_line() +
theme_tufte() +
theme(legend.position = "none") +
ggtitle("Expected loss of choosing variant B in simulated experiments") +
labs(x = "Sessions for each variant", y = "Expected loss from choosing B") +
transition_reveal(checkin)
exp.plot
anim_save(filename = "b_loss_animation.gif", animation = last_animation())
# Need to pick winner for each experiment and record time decision was made
threshold = 0.00004
outcomes = sim1 %>%
mutate(threshold.met = (loss.a < threshold | loss.b < threshold)) %>%
filter(threshold.met | checkin == max(checkin)) %>%
group_by(n.sim) %>%
filter(checkin == min(checkin)) %>%
mutate(selection = case_when(
loss.a < loss.b ~ "A",
loss.b < loss.a ~ "B"
))
outcomes %>%
ggplot(aes(x = checkin * 2)) + # Multiply by two because both variants had this many obs
stat_ecdf() +
theme_tufte() +
ggtitle("eCDF of experiment duration") +
labs(x = "Duration", y = "Percent of experiments stopped")
outcomes %>%
group_by(selection) %>%
summarise(count = n()) %>%
mutate(freq = count / sum(count)) %>%
ggplot(aes(x = selection, fill = selection, y = freq, label = round(freq, 2))) +
geom_bar(stat = "identity") +
geom_text(vjust = -0.75, size = 3) +
theme_tufte() +
ggtitle("Percent of experiments in which variant chosen") +
labs(x = "Variant", y = "Percent") +
coord_cartesian(ylim = c(0, 1)) +
theme(legend.position = "none")
setwd("~/Desktop/TestProject/june-2020")
dat = read.csv('myfilter.csv')
summary(dat[sample])
dat
dat[sample,]
dat$sample
summary(dat$sample)
dat2 = read.csv('myfilter2.csv')
dat2$names
summary(dat2$sample)
quantile(dat2$sample, probs = c(0.5, 0.6, 0.7, 0.8, 0.9))
dat2 = read.csv('myfilter2.csv')
summary(dat2$sample)
quantile(dat2$sample, probs = c(0.5, 0.6, 0.7, 0.8, 0.9))
